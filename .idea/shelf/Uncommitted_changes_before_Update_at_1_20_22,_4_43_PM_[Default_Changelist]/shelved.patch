Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/DistAuto.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/DistAuto.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Duckwheelspinblue.java
rename from TeamCode/src/main/java/org/firstinspires/ftc/teamcode/DistAuto.java
rename to TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Duckwheelspinblue.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/DistAuto.java	(revision c76457bcd414a7772e247f78ac19c0eaf60fd1f9)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Duckwheelspinblue.java	(date 1642717916357)
@@ -7,9 +7,11 @@
 
 import org.firstinspires.ftc.robotcore.external.navigation.DistanceUnit;
 
-@Autonomous (name = "DistAuto")
+@Autonomous (name = "Duckwheelspinblue")
 
-public class DistAuto extends LinearOpMode {
+public class Duckwheelspinblue extends LinearOpMode {
+
+    double distance;
 
     HardwareOmni bot = new HardwareOmni();
 
@@ -19,7 +21,7 @@
         bot.init(hardwareMap);
 
         // you can use this as a regular DistanceSensor.
-        DistanceSensor sensorRange = hardwareMap.get(DistanceSensor.class, "steven");
+        DistanceSensor sensorRange = hardwareMap.get(DistanceSensor.class, "dist");
 
         // you can also cast this to a Rev2mDistanceSensor if you want to use added
         // methods associated with the Rev2mDistanceSensor class.
@@ -32,18 +34,11 @@
         while (opModeIsActive()) {
             // generic DistanceSensor methods.
 
-            bot.BR = hardwareMap.dcMotor.get("back_right_motor");
-
-            //variable for starting duck arm program
-
-            boolean InDuckRange = false;
-
             telemetry.addData("deviceName", sensorRange.getDeviceName());
             telemetry.addData("range", String.format("%.01f cm", sensorRange.getDistance(DistanceUnit.CM)));
             double distance = sensorRange.getDistance(DistanceUnit.CM);
 
             telemetry.addData("distance", distance);
-            telemetry.addData("markus",""+bot.markus.getPower());
 
             // Rev2mDistanceSensor specific methods.
             telemetry.addData("ID", String.format("%x", sensorTimeOfFlight.getModelID()));
@@ -51,44 +46,38 @@
 
             telemetry.update();
 
-            if (distance < 10) {
+            if (distance < 20.32) {
                 bot.BL.setPower(0);
-                bot.FL.setPower(0);
                 bot.BR.setPower(0);
                 bot.FR.setPower(0);
-                InDuckRange = true;
+                bot.FL.setPower(0);
+                bot.duc.setPower(0.25);
 
-               // bot.Arm.setPower(1);
+                // bot.Arm.setPower(1);
 
-            } else if (distance < 15) {
-              //  bot.markus.setPower(0.5);
-                bot.BL.setPower(-0.25); //* 1.25);
-                bot.FL.setPower(-0.25); //* 1.25);
-                bot.BR.setPower(-0.25);// * 1.25);
-                bot.FR.setPower(-0.25);// * 1.25);
-               // bot.Arm.setPower(0);
-            } else  if (distance < 25) {
-               // bot.markus.setPower(0.75);
-                bot.BL.setPower(-0.55);// * 1.25);
-                bot.FL.setPower(-0.55);// * 1.25);
-                bot.BR.setPower(-0.55);// * 1.25);
-                bot.FR.setPower(-0.55);// * 1.25);
-               // bot.Arm.setPower(0);
-            } else if (distance >=25) {
-                bot.BL.setPower(-0.6);// * 1.25);
-                bot.FL.setPower(-0.6);// * 1.25);
-                bot.BR.setPower(-0.6);// * 1.25);
-                bot.FR.setPower(-0.6);// * 1.25);
-
-               // bot.markus.setPower(1);
-               // bot.Arm.setPower(0);
+
+            } else if (distance < 35) {
+                bot.BL.setPower(-0.5);
+                bot.BR.setPower(-0.5);
+                bot.FR.setPower(-0.5);
+                bot.FL.setPower(-0.5);
+                bot.duc.setPower(0);
+
+                // bot.Arm.setPower(0);
+
+            } else if (distance >= 40) {
+                bot.BL.setPower(-0.6);
+                bot.BR.setPower(-0.6);
+                bot.FR.setPower(-0.6);
+                bot.FL.setPower(-0.6);
+                bot.duc.setPower(0);
+
+                // bot.Arm.setPower(0);
 
-                    }
-            while (InDuckRange = true) {
-                bot.Arm.setPower(1);
-            }
-                }
-            }
+            }
+        }
+    }
+
+}
 
 
-        }
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/HardwareOmni.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* Copyright (c) 2017 FIRST. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted (subject to the limitations in the disclaimer below) provided that\n * the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice, this list\n * of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright notice, this\n * list of conditions and the following disclaimer in the documentation and/or\n * other materials provided with the distribution.\n *\n * Neither the name of FIRST nor the names of its contributors may be used to endorse or\n * promote products derived from this software without specific prior written permission.\n *\n * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS\n * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage org.firstinspires.ftc.teamcode;\n\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.DcMotorSimple;\nimport com.qualcomm.robotcore.hardware.HardwareMap;\nimport com.qualcomm.robotcore.hardware.Servo;\nimport com.qualcomm.robotcore.util.ElapsedTime;\n\n/**\n * This is NOT an opmode.\n *\n * This class can be used to define all the specific hardware for a single robot.\n * In this case that robot is a Pushbot.\n * See PushbotTeleopTank_Iterative and others classes starting with \"Pushbot\" for usage examples.\n *\n * This hardware class assumes the following device names have been configured on the robot:\n * Note:  All names are lower case and some have single spaces between words.\n */\n//crossroads is password to control hub\n          /* Motors:\n  back_right_motor\n  front_right_motor\n  arm_motor\n  front_left_motor\n  back_left_motor\nServos:\n  hand_servo*/\n\n\npublic class HardwareOmni\n{\n    /* Public OpMode members. */\n    public DcMotor  BL   = null;\n    public DcMotor  BR  = null;\n    public DcMotor  FR     = null;\n    public DcMotor  FL     = null;\n    public DcMotor  Arm     = null;\n    public DcMotor  duck     = null;\n    public DcMotor  markus     = null;\n    public Servo    HSL    = null;\n    public Servo    HSR  = null;\n\n    public static final double MID_SERVO       =  0.5 ;\n    public static final double ARM_UP_POWER    =  0.45 ;\n    public static final double ARM_DOWN_POWER  = -0.45 ;\n\n    /* local OpMode members. */\n    HardwareMap hwMap           =  null;\n    private ElapsedTime period  = new ElapsedTime();\n\n    /* Constructor */\n    public HardwareOmni(){\n\n    }\n\n    /* Initialize standard Hardware interfaces */\n    public void init(HardwareMap ahwMap) {\n        // Save reference to Hardware map\n        hwMap = ahwMap;\n\n        // Define and Initialize Motors\n        BL  = hwMap.get(DcMotor.class, \"back_left_motor\");\n        BR = hwMap.get(DcMotor.class, \"back_right_motor\");\n        FL = hwMap.get(DcMotor.class, \"front_left_motor\");\n        FR = hwMap.get(DcMotor.class, \"front_right_motor\");\n        Arm = hwMap.get(DcMotor.class, \"arm_motor\");\n        markus = hwMap.get(DcMotor.class, \"markus\");\n        duck = hwMap.get(DcMotor.class, \"duck\");\n        BL.setDirection(DcMotor.Direction.REVERSE); // Set to REVERSE if using AndyMark motors\n        FL.setDirection(DcMotorSimple.Direction.REVERSE);\n\n        // Set all motors to zero power\n      BR.setPower(0);\n      BL.setPower(0);\n      FR.setPower(0);\n      FL.setPower(0);\n      Arm.setPower(0);\n      markus.setPower(0);\n      duck.setPower(0);\n\n\n        // Set all motors to run without encoders.\n        // May want to use RUN_USING_ENCODERS if encoders are installed.\n        BR.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        BL.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        FR.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        FL.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        Arm.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        markus.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        duck.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n\n        // Define and initialize ALL installed servos.\n       HSL  = hwMap.get(Servo.class, \"hand_servo_left\");\n       HSR = hwMap.get(Servo.class, \"hand_servo_right\");\n    }\n }\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/HardwareOmni.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/HardwareOmni.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/HardwareOmni.java	(revision c76457bcd414a7772e247f78ac19c0eaf60fd1f9)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/HardwareOmni.java	(date 1642717916345)
@@ -64,7 +64,7 @@
     public DcMotor  FR     = null;
     public DcMotor  FL     = null;
     public DcMotor  Arm     = null;
-    public DcMotor  duck     = null;
+    public DcMotor  duc     = null;
     public DcMotor  markus     = null;
     public Servo    HSL    = null;
     public Servo    HSR  = null;
@@ -93,8 +93,7 @@
         FL = hwMap.get(DcMotor.class, "front_left_motor");
         FR = hwMap.get(DcMotor.class, "front_right_motor");
         Arm = hwMap.get(DcMotor.class, "arm_motor");
-        markus = hwMap.get(DcMotor.class, "markus");
-        duck = hwMap.get(DcMotor.class, "duck");
+        duc = hwMap.get(DcMotor.class, "duck");
         BL.setDirection(DcMotor.Direction.REVERSE); // Set to REVERSE if using AndyMark motors
         FL.setDirection(DcMotorSimple.Direction.REVERSE);
 
@@ -104,8 +103,8 @@
       FR.setPower(0);
       FL.setPower(0);
       Arm.setPower(0);
-      markus.setPower(0);
-      duck.setPower(0);
+      Arm.setPower(0);
+      duc.setPower(0);
 
 
         // Set all motors to run without encoders.
@@ -115,8 +114,7 @@
         FR.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
         FL.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
         Arm.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
-        markus.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
-        duck.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
+        duc.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
 
         // Define and initialize ALL installed servos.
        HSL  = hwMap.get(Servo.class, "hand_servo_left");
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/dist.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nCopyright (c) 2018 FIRST\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted (subject to the limitations in the disclaimer below) provided that\nthe following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list\nof conditions and the following disclaimer.\n\nRedistributions in binary form must reproduce the above copyright notice, this\nlist of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\nNeither the name of FIRST nor the names of its contributors may be used to\nendorse or promote products derived from this software without specific prior\nwritten permission.\n\nNO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS\nLICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\nTORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\nTHIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\npackage org.firstinspires.ftc.teamcode;\n\nimport com.qualcomm.hardware.rev.Rev2mDistanceSensor;\nimport com.qualcomm.robotcore.eventloop.opmode.Disabled;\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.DistanceSensor;\n\nimport org.firstinspires.ftc.robotcore.external.navigation.DistanceUnit;\n\n/**\n * {@link dist} illustrates how to use the REV Robotics\n * Time-of-Flight Range Sensor.\n *\n * The op mode assumes that the range sensor is configured with a name of \"sensor_range\".\n *\n * Use Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.\n * Remove or comment out the @Disabled line to add this opmode to the Driver Station OpMode list\n *\n * @see <a href=\"http://revrobotics.com\">REV Robotics Web Page</a>\n */\n@TeleOp(name = \"dist\", group = \"Sensor\")\n//Disabled\npublic class dist extends LinearOpMode {\n\n    double distance;\n    DcMotor BR;\n\n\n    private DistanceSensor sensorRange;\n\n    @Override\n    public void runOpMode() {\n        // you can use this as a regular DistanceSensor.\n        sensorRange = hardwareMap.get(DistanceSensor.class, \"steven\");\n\n        // you can also cast this to a Rev2mDistanceSensor if you want to use added\n        // methods associated with the Rev2mDistanceSensor class.\n        Rev2mDistanceSensor sensorTimeOfFlight = (Rev2mDistanceSensor)sensorRange;\n\n        telemetry.addData(\">>\", \"Press start to continue\");\n        telemetry.update();\n\n        waitForStart();\n        while(opModeIsActive()) {\n            // generic DistanceSensor methods.\n\n            BR = hardwareMap.dcMotor.get(\"back_right_motor\");\n\n            telemetry.addData(\"deviceName\",sensorRange.getDeviceName() );\n            telemetry.addData(\"range\", String.format(\"%.01f cm\", sensorRange.getDistance(DistanceUnit.CM)));\n            distance = sensorRange.getDistance(DistanceUnit.CM);\n\n            telemetry.addData(\"distance\", distance);\n\n\n\n            // Rev2mDistanceSensor specific methods.\n            telemetry.addData(\"ID\", String.format(\"%x\", sensorTimeOfFlight.getModelID()));\n            telemetry.addData(\"did time out\", Boolean.toString(sensorTimeOfFlight.didTimeoutOccur()));\n\n            telemetry.update();\n\n            if (distance < 5) {\n                BR.setPower(0);\n\n            } else {\n                BR.setPower(1);\n            }\n\n        }\n\n    }\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/dist.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/dist.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/dist.java	(revision c76457bcd414a7772e247f78ac19c0eaf60fd1f9)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/dist.java	(date 1642717916370)
@@ -101,7 +101,10 @@
                 BR.setPower(1);
             }
 
-        }
+
+
+
+            }
 
     }
 
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/HardwareAuto.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode;\n\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.util.ElapsedTime;\nimport java.util.concurrent.TimeUnit;\nimport java.util.Date;\n//hello\n\n@Autonomous(name = \"HardwareAuto\")\npublic class HardwareAuto extends LinearOpMode {\n\n    HardwareOmni        bot = new HardwareOmni();\n\n\n\n    double pos = 0;\n    int r = 0;\n\n    double speed = 1;\n    private ElapsedTime     runtime = new ElapsedTime();\n\n\n\n    @Override\n    public void runOpMode() throws InterruptedException {\n        bot.init(hardwareMap);\n        bot.markus.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        bot.BR.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        bot.BL.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        bot.FL.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        bot.FR.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n\n\n        bot.markus.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        bot.BR.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        bot.BL.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        bot.FR.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        bot.FL.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n\n\n        waitForStart();\n\n\n            //functions that control the drive motors, \n        duckdrive(speed, 4000, 0, false, 0);//for reverse 0 is forwards 1 is backwards\n        duckdrive(speed, 0, 0, true,100);\n        duckdrive(speed, 8000, 1, false,0);\n        duckdrive(speed, 0, 0, false,0);\n        duckdrive(speed, 2000, 0, false,0);\n        duckdrive(speed, 2000, 1, false,0);\n\n\n\n\n\n        telemetry.addData(\"stop\",\"\");\n\n\n\n\n\n    }\n\n    private void duckdrive(double speed, int forward, int reverse, boolean duckwheel, double extrawait) {\n        bot.markus.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        bot.BR.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        bot.BL.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        bot.FL.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        bot.FR.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n\n\n        bot.markus.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        bot.BR.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        bot.BL.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        bot.FR.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        bot.FL.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n\n\n\n\n\n        if(reverse == 0) {\n            bot.markus.setTargetPosition(forward);\n        }\n        else if (reverse == 1){\n            bot.markus.setTargetPosition(forward*-1);\n        }\n\n\n\n\n        bot.markus.setPower(speed);\n\n        runtime.reset();\n\n        if(duckwheel){\n            bot.duck.setPower(1);\n        }\n        else {\n            bot.duck.setPower(0);\n        }\n\n\n        if (reverse == 0) {\n            while (pos < forward && runtime.seconds() < 10 && opModeIsActive()) {\n\n\n                pos = bot.markus.getCurrentPosition();\n                telemetry.addData(\"forward\", \"\" + pos);\n                telemetry.addData(\"time\", \"\" + runtime.seconds());\n\n\n                telemetry.update();\n\n            }\n\n\n        }\n        else if (reverse == 1){\n            while (pos > forward*-1 && runtime.seconds() < 10 && opModeIsActive()) {\n\n\n                pos = bot.markus.getCurrentPosition();\n                telemetry.addData(\"forward\", \"\" + pos);\n                telemetry.addData(\"time\", \"\" + runtime.seconds());\n\n\n                telemetry.update();\n            }\n        }\n\n\n    }\n\n\n\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/HardwareAuto.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/HardwareAuto.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/HardwareAuto.java	(revision c76457bcd414a7772e247f78ac19c0eaf60fd1f9)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/HardwareAuto.java	(date 1642717916377)
@@ -96,10 +96,10 @@
         runtime.reset();
 
         if(duckwheel){
-            bot.duck.setPower(1);
+            bot.duc.setPower(1);
         }
         else {
-            bot.duck.setPower(0);
+            bot.duc.setPower(0);
         }
 
 
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/AllianceParkBlueAuto.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/AllianceParkBlueAuto.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/AllianceParkBlueAuto.java
new file mode 100644
--- /dev/null	(date 1642717916386)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/AllianceParkBlueAuto.java	(date 1642717916386)
@@ -0,0 +1,67 @@
+package org.firstinspires.ftc.teamcode;
+
+import com.qualcomm.hardware.rev.Rev2mDistanceSensor;
+import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
+import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
+import com.qualcomm.robotcore.hardware.DistanceSensor;
+
+import org.firstinspires.ftc.robotcore.external.navigation.DistanceUnit;
+
+@Autonomous (name = "AllianceParkBlueAuto")
+
+public class AllianceParkBlueAuto extends LinearOpMode {
+
+    HardwareOmni bot = new HardwareOmni();
+
+
+    @Override
+    public void runOpMode() {
+        bot.init(hardwareMap);
+
+        // you can use this as a regular DistanceSensor.
+        DistanceSensor sensorRange = hardwareMap.get(DistanceSensor.class, "dist");
+
+        // you can also cast this to a Rev2mDistanceSensor if you want to use added
+        // methods associated with the Rev2mDistanceSensor class.
+        Rev2mDistanceSensor sensorTimeOfFlight = (Rev2mDistanceSensor) sensorRange;
+
+        telemetry.addData(">>", "Press start to continue");
+        telemetry.update();
+
+        waitForStart();
+        while (opModeIsActive()) {
+            // generic DistanceSensor methods.
+
+            telemetry.addData("deviceName", sensorRange.getDeviceName());
+            telemetry.addData("range", String.format("%.01f cm", sensorRange.getDistance(DistanceUnit.CM)));
+            double distance = sensorRange.getDistance(DistanceUnit.CM);
+
+            telemetry.addData("distance", distance);
+            telemetry.addData("markus", "" + bot.markus.getPower());
+
+            // Rev2mDistanceSensor specific methods.
+            telemetry.addData("ID", String.format("%x", sensorTimeOfFlight.getModelID()));
+            telemetry.addData("did time out", Boolean.toString(sensorTimeOfFlight.didTimeoutOccur()));
+
+            telemetry.update();
+
+            if (distance < 5) {
+                bot.BL.setPower(0);
+                bot.BR.setPower(0);
+                bot.FR.setPower(0);
+                bot.FL.setPower(0);
+
+
+                // bot.Arm.setPower(1);
+
+            } else if (distance > 5) {
+                bot.BL.setPower(-0.3);
+                bot.BR.setPower(-0.3);
+                bot.FR.setPower(-0.3);
+                bot.FL.setPower(-0.3);
+            }
+        }
+    }
+
+
+}
\ No newline at end of file
